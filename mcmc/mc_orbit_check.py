import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
import numpy as np
from mc_motionfit import cv,ca
import triangle
from koe import koe

import jdcal as jdcal
import datetime as dt


#Script to plot naive and mcmc-restricted quadratic fits to fomalhaut b's motion
#As generated by "mc_motionfit.py"

#THIS IS A VERY GOOD PLOT.
#Consider computing the chi-squared evolution for EVERY orbit in the chain.
#It would also be very interesting to compare the best-fit chi^2 and the linear chi^2
#as they EVOLVE with differing numbers, precisions, epochs, and astrometric coordinates
#of new observations.


filename='fomalhaut_new.csv'

t=np.genfromtxt(filename, skip_header=1,delimiter=',', usecols=(9), unpack=True).T.ravel()
x = np.genfromtxt(filename, skip_header=1,delimiter=',',usecols=(11),unpack=True).T.ravel()/1000.
y = np.genfromtxt(filename, skip_header=1,delimiter=',',usecols=(13),unpack=True).T.ravel()/1000.
sig_x = np.genfromtxt(filename, skip_header=1,delimiter=',',usecols=(12),unpack=True).T.ravel()/1000.
sig_y = np.genfromtxt(filename, skip_header=1,delimiter=',',usecols=(14),unpack=True).T.ravel()/1000.

epochs=(np.genfromtxt(filename, skip_header=1,delimiter=',', usecols=(9,10), unpack=True)).T.ravel()
xy=(np.genfromtxt(filename, skip_header=1,delimiter=',', usecols=(11,13), unpack=True)).T.ravel()/1000
sig=(np.genfromtxt(filename, skip_header=1,delimiter=',', usecols=(12,14), unpack=True)).T.ravel()/1000

#pickle_filename = 'F:/mcmc/fmh_new_longtest1'
pickle_filename = 'fmh_new_priorstest2'

num_files=10
nperfile=25000
acceptance_fraction = np.zeros((128*num_files))
acor = np.zeros((6*num_files))
chain = np.zeros((128,nperfile*num_files,6))
lnprobability = np.zeros((128,nperfile*num_files))

for i in range(num_files):
    with np.load(pickle_filename+'_'+str(i)+'.npz') as d:
        acceptance_fraction[128*i:128*(i+1)] = d['af']
        acor[6*i:6*(i+1)] = d['ac']
        chain[:,nperfile*i:nperfile*(i+1),:]=d['chain']
        lnprobability[:,nperfile*i:nperfile*(i+1)]=d['lnp']

tmp=chain[:,:,1]
tmp[tmp > 0.5] -= 1.
chain[:,:,1]=tmp

#We'll wrap argp about 360 degrees
tmp=chain[:,:,2]
tmp[tmp > np.radians(360)] -= np.radians(360)
chain[:,:,2]=tmp

#Thin it out by the maximum autocorrelation
thinf = np.ceil(np.nanmax(acor))

lna  = chain[:,:,0].flatten()[::thinf]
tau  = chain[:,:,1].flatten()[::thinf]
argp = chain[:,:,2].flatten()[::thinf]
lan  = chain[:,:,3].flatten()[::thinf]
cinc = chain[:,:,4].flatten()[::thinf]
ecc  = chain[:,:,5].flatten()[::thinf]

#Where is the maximum probability? 
lnp =  lnprobability.flatten()[::thinf]
w = np.argmax(lnp)

#Get the maximum likely
lna_ml=lna[w]
tau_ml=tau[w]
argp_ml=argp[w]
lan_ml=lan[w]
cinc_ml=cinc[w]
ecc_ml=ecc[w]

#Calculate the inclination in degrees
inc=np.degrees(np.arccos(cinc))
inc_ml=np.degrees(np.arccos(cinc_ml))
        
chain[:,:,0]=np.exp(chain[:,:,0]) #Get the SMA in AU
chain[:,:,2]=np.degrees(chain[:,:,2]) # In degrees
chain[:,:,3]=np.degrees(chain[:,:,3]) # In degrees
chain[:,:,4]=np.degrees(np.arccos(chain[:,:,4])) #in degrees

P = np.sqrt(chain[:,:,0]**3./1.92)*365.2425

chain[:,:,1]=((chain[:,:,1]*P)+50000-49718)%P+49718

DT = 50000.        # my time offset from MJD
MJD0 = 2400000.5   # zero point for JD
# generate range of dates 
epo_pad = 365*120
epo = np.linspace(np.nanmin(epochs)-epo_pad,np.nanmax(epochs)+epo_pad,num=1000)

epo = np.column_stack((epo,epo)).flatten()
#convert epochs to datetime stucture
ddt = np.array([])
for ep in epo:
    y,m,d,h = jdcal.jd2gcal(MJD0 + DT, ep)
    ddt = np.append(ddt,dt.datetime(y,m,d))
# convert observed dates for plotting
epochdt = np.array([])

##### Convert the Data epochs #### 

for ep in epochs:
    y,m,d,h = jdcal.jd2gcal(MJD0 + DT, ep)
    epochdt = np.append(epochdt,dt.datetime(y,m,d))

fig = plt.figure()
ax1 = fig.add_subplot(121)
    
#Plot a horizontal line at 0
plt.axhline(y=0,ls='--',color='k')

#Get the orbit and plot it for npts
npts = 50
rindex = np.floor(np.random.random(npts) * np.size(lna))
for i in rindex:
    XY = koe(epo,np.exp(lna[i]),tau[i],argp[i],lan[i],np.arccos(cinc[i]),ecc[i])
    plt.plot(ddt[0::2],XY[0::2],'r:',linewidth=1, alpha=0.05)
    plt.plot(ddt[1::2],XY[1::2],'b:',linewidth=1, alpha=0.05)


#Plot the most likely solution
XY=koe(epo,np.exp(lna_ml),tau_ml,argp_ml,lan_ml,np.arccos(cinc_ml),ecc_ml)

plt.plot(ddt[0::2],XY[0::2],'k',linewidth=1.5)
plt.plot(ddt[1::2],XY[1::2],'k',linewidth=1.5)

#### Plot the position of the planet ####

plt.errorbar(epochdt[0::2],xy[0::2],yerr=sig[0::2],fmt='ro',ecolor='k', elinewidth=2, capthick=2, ms=2)
plt.plot(epochdt[0::2],xy[0::2],'ro',mew=1.5,label=r'X')
plt.legend(numpoints=1,markerscale=2,loc=2)

plt.errorbar(epochdt[1::2],xy[1::2],yerr=sig[1::2],fmt='bo',ecolor='k', elinewidth=2, capthick=2, ms=2)
plt.plot(epochdt[1::2],xy[1::2],'bo',mew=1.5,label=r'Y')
plt.legend(numpoints=1,markerscale=2,loc=2)


### Set titles and limits ###
plt.xlim(dt.datetime(2002, 1,1),dt.datetime(2070, 1,1))
plt.ylabel('Offset [arcsec]')
plt.xlabel('Date [year]')


#Quantitative evaluation of future position of the planet
last=np.max(epochs)
future = np.linspace(last+10.*365.2425,last+50.*365.2425,5.)
future = np.column_stack((future,future)).flatten()
future_xy = koe(future,np.exp(lna_ml),tau_ml,argp_ml,lan_ml,np.arccos(cinc_ml),ecc_ml)

futuredt=np.array([])
futuresig=np.array([])
for ep in future:
    y,m,d,h = jdcal.jd2gcal(MJD0 + DT, ep)
    futuredt = np.append(futuredt,dt.datetime(y,m,d))
    futuresig = np.append(futuresig,sig[-1])

plt.errorbar(futuredt[0::2],future_xy[0::2],yerr=futuresig[0::2],fmt='mo',ecolor='k',elinewidth=2,capthick=2,ms=2)
plt.errorbar(futuredt[0::2],future_xy[0::2],yerr=0.1*futuresig[0::2],fmt='mo',ecolor='g',elinewidth=2,capthick=2,ms=2)
plt.plot(futuredt[0::2],future_xy[0::2],'mo',mew=1.5,label=r'Projected X')
plt.legend(numpoints=1,markerscale=2,loc=2)

plt.errorbar(futuredt[1::2],future_xy[1::2],yerr=futuresig[1::2],fmt='co',ecolor='k',elinewidth=2,capthick=2,ms=2)
plt.errorbar(futuredt[1::2],future_xy[1::2],yerr=0.1*futuresig[1::2],fmt='co',ecolor='g',elinewidth=2,capthick=2,ms=2)
plt.plot(futuredt[1::2],future_xy[1::2],'co',mew=1.5,label=r'Projected Y')
plt.legend(numpoints=1,markerscale=2,loc=2)



#fig=triangle.corner(samples,labels=labels,show_titles=True,plot_datapoints=False)

#fig.subplots_adjust(hspace=0)
#fig.subplots_adjust(wspace=0)

#plt2=fig.add_subplot(3,3,3)

start=np.min(t)
times=np.linspace(start-365.2425*10,start+365.2425*130,2000)
timesdt = np.array([])
for ti in times:
    y,m,d,h = jdcal.jd2gcal(MJD0 + DT, ti)
    timesdt = np.append(timesdt,dt.datetime(y,m,d))


with np.load('fmh_simplefit.npz') as d:
    pvx=d['pvx']
    pvy=d['pvy']

plt.plot(timesdt,cv(times,*pvx),'r-')
plt.plot(timesdt,cv(times,*pvy),'b-')

#compute a chi^2 for each of the things (ml, 50 random, linear)
all_pos = np.concatenate((xy,future_xy))
all_sig = np.concatenate((sig,futuresig))
all_sig_optimistic = np.concatenate((sig,futuresig*0.1))
all_eps = np.concatenate((epochs,future))

def prob_kep(theta,eps,xy,sig):
    loga = theta[0]
    tau  = theta[1]
    argp = theta[2]
    lan  = theta[3]
    cinc = theta[4]
    ecc  = theta[5]

    
    a = np.exp(loga)
    inc = np.arccos(cinc)
    
    XY=koe(eps,a,tau,argp,lan,inc,ecc)
    
    lpx = -0.5*np.log(2*np.pi) * xy.size + \
                   np.sum( -np.log(sig)- 0.5*( (xy-XY)/sig)**2)
    
    return np.exp(lpx)

def prob_lin(mx,my,bx,by,eps,xy,sig):
    X = cv(eps[0::2],mx,bx)
    Y = cv(eps[1::2],my,by)
    XY = np.column_stack((X,Y)).flatten()
    lpx = -0.5*np.log(2*np.pi) * xy.size + \
                    np.sum( -np.log(sig)- 0.5*( (xy-XY)/sig)**2)
    
    return np.exp(lpx)
    
def chi2(xy,XY,sig):
    return np.sum(np.abs((xy-XY)**2./sig**2.))/(np.size(xy)-7.)

oldchis=np.zeros(52.)
newchis=np.zeros(52.)
optchis=np.zeros(52.)
for i,r in enumerate(rindex):
    theta=(np.exp(lna[r]),tau[r],argp[r],lan[r],np.arccos(cinc[r]),ecc[r])
    XY=koe(epochs,*theta)
    oldchis[i] = chi2(xy,XY,sig)
    XY2=koe(all_eps,*theta)
    newchis[i] = chi2(all_pos,XY2,all_sig)
    optchis[i] = chi2(all_pos,XY2,all_sig_optimistic)
    
theta = (np.exp(lna_ml),tau_ml,argp_ml,lan_ml,np.arccos(cinc_ml),ecc_ml)
XY=koe(epochs,*theta)
oldchis[50]=chi2(xy,XY,sig)
print 'xy: '
print xy
print 'XY: '
print XY
XY2=koe(all_eps,*theta)
newchis[50] = chi2(all_pos,XY2,all_sig)
optchis[50] = chi2(all_pos,XY2,all_sig_optimistic)

X=cv(epochs[0::2],pvx[0],pvx[1])
Y=cv(epochs[1::2],pvy[0],pvy[1])
XY = np.column_stack((X,Y)).flatten()
print 'xy lin: '
print xy
print 'XY lin: '
print XY

oldchis[51]=chi2(xy,XY,sig)
X=cv(all_eps[0::2],pvx[0],pvx[1])
Y=cv(all_eps[1::2],pvy[0],pvy[1])
XY = np.column_stack((X,Y)).flatten()
newchis[51]=chi2(all_pos,XY,all_sig)
optchis[51]=chi2(all_pos,XY,all_sig_optimistic)

ax2=fig.add_subplot(122)
plt.plot(oldchis[:50],newchis[:50],'go',label=r'Random')
plt.legend(numpoints=1,markerscale=2,loc=4)
plt.plot(oldchis[50],newchis[50],'ro',label=r'Best Fit')
plt.legend(numpoints=1,markerscale=2,loc=4)
plt.plot(oldchis[51],newchis[51],'co',label=r'Linear Motion')
plt.legend(numpoints=1,markerscale=2,loc=4)
zulu=np.logspace(-3,6,100)
plt.plot(zulu,zulu,'k-')
plt.yscale('log')
plt.ylabel('New chi^2')
plt.xscale('log')
plt.xlabel('Old chi^2')


plt.savefig('quant_check.svg')

plt.show()